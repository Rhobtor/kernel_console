# Progress Log - December 18, 2025

## Project Overview
Building a custom Linux kernel for ARM-based console systems using a Raspberry Pi as the development platform.

---

## Phase 1: Prepare Environment and Compile Kernel

### 1.1 Check Raspberry Pi Architecture

**What you did:**
```bash
uname -m
```

**Purpose:**
Confirms that the Raspberry Pi is running in aarch64 (64-bit mode). This determines which kernel version and configuration files you'll use for compilation.

---

### 1.2 Install Build Tools

**What you did:**
```bash
sudo apt update
sudo apt install -y git bc bison flex libssl-dev make libc6-dev libncurses5-dev
```

**Key tools explained:**
- **git** â†’ Downloads the kernel source code from repositories
- **bc** â†’ Calculator utility used by the kernel build system
- **bison, flex** â†’ Parser and lexer generators (used by kernel build tools)
- **libssl-dev** â†’ Cryptographic libraries for kernel components
- **make** â†’ Orchestrator and compiler for the entire kernel build process
- **libc6-dev, libncurses5-dev** â†’ Header files and libraries needed to compile kernel tools

---

### 1.3 Download Raspberry Pi Kernel Source

**What you did:**
```bash
cd ~
mkdir -p kernel_test
cd kernel_test
git clone --depth=1 https://github.com/raspberrypi/linux
cd linux
```

**What each part does:**
- **Repository** â†’ Contains the Linux kernel source code adapted specifically for Raspberry Pi
- **--depth=1** â†’ Only clones the latest version (saves space on SD card)
- Creates a clean directory structure for kernel development

---

### 1.4 Generate Base Configuration for Pi 4

**What you did:**
```bash
export KERNEL=kernel8
make bcm2711_defconfig
```

**What it does:**
- **bcm2711_defconfig** â†’ Default configuration template for BCM2711 SoC (Raspberry Pi 4)
- Creates a `.config` file with thousands of kernel options (drivers, filesystems, networking, etc.)
- Provides a stable starting point optimized for your specific hardware

---

### 1.5 Add Custom Signature to Kernel

**What you did:**
Edit `.config`:
```bash
nano .config
# Search for:
CONFIG_LOCALVERSION=
# Change to:
CONFIG_LOCALVERSION="-console-v1"
```

**Why this matters:**
- **CONFIG_LOCALVERSION** â†’ Gets appended to the kernel version string
- When you run `uname -a`, you'll see `... -console-v1` at the end
- Identifies this as YOUR custom compiled kernel (not the default Pi kernel)

---

### 1.6 Compile Kernel, Modules, and Device Trees

**What you did:**
```bash
make -j4 Image.gz modules dtbs
```

**What each component produces:**
- **Image.gz** â†’ Compressed kernel image (the core kernel binary)
- **modules** â†’ Driver files (.ko) that load dynamically at runtime
- **dtbs** â†’ Device Tree Blobs (hardware description files mapping the board layout)
- **-j4** â†’ Uses 4 parallel threads (all cores on Raspberry Pi 4)

**Time:** This takes 20-40 minutes depending on your system

---

### 1.7 Install Compiled Modules

**What you did:**
```bash
sudo make modules_install
```

**Purpose:**
- Copies all compiled modules to `/lib/modules/<version>-console-v1/`
- This is where the system looks for drivers when you use `modprobe` or `insmod`
- Makes drivers available to your running kernel

---

## Phase 2: Install and Boot with Your Kernel

### 2.1 Copy Compiled Kernel to Boot Partition

**What you did:**
```bash
cd ~/kernel_test/linux
sudo cp arch/arm64/boot/Image.gz /boot/firmware/kernel8-console-v1.img
```

**Why this naming:**
- Gives your kernel a unique name â†’ doesn't overwrite the original
- Preserves the default Pi kernel as backup

---

### 2.2 Configure Firmware to Use Your Kernel

**What you did:**
```bash
sudo nano /boot/firmware/config.txt
```

**Add or ensure these lines:**
```
arm_64bit=1
kernel=kernel8-console-v1.img
#auto_initramfs=1
```

**What each line does:**
- **kernel=kernel8-console-v1.img** â†’ Tells GPU to load your custom kernel
- **arm_64bit=1** â†’ Boot in 64-bit mode
- **#auto_initramfs=1** â†’ Commented out to avoid conflicts with custom initramfs

**Verification after reboot:**
```bash
uname -a
```

You should see:
```
Linux raspberrypi 6.12.60-console-v1+ ...
```

âœ… **Success!** Your Raspberry Pi is now running YOUR compiled kernel.

---

## Phase 3: Create Minimal Rootfs with BusyBox

Now you transition from "just a kernel" to building your own minimal operating system (userspace).

### 3.1 Create Development Directory

**What you did:**
```bash
cd ~
mkdir -p os_lab
cd os_lab
```

Creates isolated workspace for OS development.

---

### 3.2 Download BusyBox

**What you did:**
```bash
wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2
tar xf busybox-1.36.1.tar.bz2
cd busybox-1.36.1
```

**What BusyBox is:**
- Single binary that implements 300+ Unix tools (sh, ls, cp, cat, grep, wget, etc.)
- Perfect for embedded systems with minimal storage
- Replaces bash, coreutils, and many other packages

---

### 3.3 Configure BusyBox

**What you did:**
```bash
make defconfig
make menuconfig
```

**Critical settings in menuconfig:**

Disable Traffic Control (tc) to avoid build errors:
- Navigate to: `Networking Utilities`
- Uncheck `tc`

Enable static compilation (do this later if needed):
- Navigate to: `Settings`
- Enable `Build static binary (no shared libs)` â†’ [*]
- This makes busybox self-contained (no dependency on /lib)

---

### 3.4 Compile BusyBox

**What you did:**
```bash
make clean
make -j4
```

Compiles the single BusyBox binary and all its applets (symlinks).

---

### 3.5 Install BusyBox to Your Rootfs

**What you did:**
```bash
mkdir -p ~/os_lab/rootfs
make CONFIG_PREFIX=~/os_lab/rootfs install
```

**Creates this structure:**
```
rootfs/
  bin/busybox          (the main binary)
  bin/sh -> busybox    (symlink)
  bin/ls -> busybox    (symlink)
  bin/cp -> busybox    (symlink)
  sbin/
  usr/
  ... (other applets)
```

This `rootfs/` is the foundation of YOUR custom filesystem.

---

## Phase 4: Mount Required Filesystems and Create Init

### 4.1 Create Essential Directories

**What you did:**
```bash
cd ~/os_lab/rootfs
sudo mkdir -p dev proc sys tmp mnt
sudo chmod 1777 tmp
```

**What each directory does:**
- **dev/** â†’ Device nodes (/dev/console, /dev/null, /dev/sda, etc.)
- **proc/** â†’ Virtual filesystem for kernel info (/proc/cpuinfo, /proc/meminfo, etc.)
- **sys/** â†’ Virtual filesystem for device information (/sys/devices, /sys/class, etc.)
- **tmp/** â†’ Temporary files (sticky bit `1777` prevents users from deleting each other's files)
- **mnt/** â†’ Mount point for external storage (SD card partitions, USB drives, etc.)

---

### 4.2 Create Special Device Nodes

**What you did:**
```bash
cd ~/os_lab/rootfs
sudo mknod dev/console c 5 1
sudo mknod dev/null    c 1 3
sudo chmod 600 dev/console
sudo chmod 666 dev/null
```

**Why these are critical:**
- **dev/console** â†’ The kernel REQUIRES this for output messages and terminal input
- **dev/null** â†’ The "black hole" device (discards all data written to it)
- Character device format: `mknod <name> c <major> <minor>`

Without `/dev/console`, the kernel can't communicate with you!

---

### 4.3 Create Your First Init Script (v0.3)

**What you did:**
```bash
cd ~/os_lab/rootfs
sudo nano init
```

**Content (your current working version):**
```bash
#!/bin/sh

echo ""
echo "====================================="
echo "  Init minimal de la consola (v0.3)"
echo "====================================="
echo ""

# Mount /proc and /sys if not already mounted
mount -t proc proc /proc 2>/dev/null || echo "proc ya montado"
mount -t sysfs sys /sys 2>/dev/null || echo "sys ya montado"

echo ""
echo "Montado /proc y /sys (o ya lo estaban)"
echo ""

# Ensure /dev/console and /dev/null exist
[ -e /dev/console ] || mknod /dev/console c 5 1
[ -e /dev/null ]    || mknod /dev/null    c 1 3
chmod 600 /dev/console
chmod 666 /dev/null

echo "Entrando en shell BusyBox..."
exec /bin/sh
```

**Make it executable:**
```bash
sudo chmod +x init
```

**How this works:**
- `/init` becomes PID 1 when your kernel starts (the very first process)
- Mounts critical pseudo-filesystems (/proc, /sys)
- Ensures device nodes exist
- Drops you into a BusyBox shell as root

---

## Phase 5: Test Rootfs Safely with Chroot

**Important:** Test your rootfs WITHOUT affecting boot before deploying it.

**What you did:**
```bash
cd ~/os_lab/rootfs

sudo mount --bind /dev dev
sudo mount -t proc proc proc
sudo mount -t sysfs sys sys

sudo chroot . /init
```

**What you see:**
```
=====================================
  Init minimal de la consola (v0.3)
=====================================

Montado /proc y /sys (o ya lo estaban)

Entrando en shell BusyBox...
/ #
```

**What's happening:**
- You're inside your custom rootfs
- Using your compiled BusyBox
- On the kernel that's running the Pi (which is YOUR -console-v1 kernel)
- `uname -a` still shows your kernel

**Exit and cleanup:**
```bash
/ # exit

cd ~/os_lab/rootfs
sudo umount dev proc sys
```

---

## Phase 6: Package Rootfs as Initramfs

### 6.1 Create Initramfs Archive

**What you did:**
```bash
cd ~/os_lab/rootfs
sudo find . | cpio -H newc -o | gzip > ../initramfs-console-v2.cpio.gz
```

**What this does:**
- **find .** â†’ Lists all files in your rootfs
- **cpio -H newc -o** â†’ Creates standard initramfs format (newc is the modern format)
- **gzip** â†’ Compresses the archive
- Result: `initramfs-console-v2.cpio.gz` containing your entire filesystem in RAM

---

### 6.2 Copy Initramfs to Boot Partition

**What you did:**
```bash
cd ~/os_lab
sudo cp initramfs-console-v2.cpio.gz /boot/firmware/
```

Makes it available during boot.

---

### 6.3 Configure Firmware to Load Kernel + Initramfs

**What you did:**
```bash
sudo nano /boot/firmware/config.txt
```

**Ensure these lines:**
```
arm_64bit=1
kernel=kernel8-console-v1.img
initramfs initramfs-console-v2.cpio.gz followkernel
#auto_initramfs=1
```

**What each line does:**
- **kernel=kernel8-console-v1.img** â†’ GPU loads your kernel
- **initramfs initramfs-console-v2.cpio.gz followkernel** â†’ GPU loads your initramfs and passes it to kernel
- GPU runs before the kernel and loads both files into memory

---

### 6.4 Configure Kernel to Use Initramfs as Root

**What you did:**
```bash
sudo cp /boot/firmware/cmdline.txt /boot/firmware/cmdline.txt.backup
sudo nano /boot/firmware/cmdline.txt
```

**Replace the entire line with:**
```
console=serial0,115200 console=tty1 root=/dev/ram0 rw rdinit=/init
```

**What each parameter does:**
- **console=serial0,115200** â†’ Send kernel messages to serial port at 115200 baud
- **console=tty1** â†’ Also send messages to HDMI/display (tty1)
- **root=/dev/ram0** â†’ Root filesystem is a ramdisk (your initramfs)
- **rw** â†’ Mount root as read-write
- **rdinit=/init** â†’ Execute `/init` from the initramfs (not from disk)

---

### 6.5 Boot and Verify

**What you did:**
```bash
sudo reboot
```

**Before:** Raspberry Pi OS boots normally

**After:** You see:
```
=====================================
  Init minimal de la consola (v0.3)
=====================================

Montado /proc y /sys (o ya lo estaban)

Entrando en shell BusyBox...
/ #
```

**Verify what you're running:**
```bash
/ # uname -a
Linux raspberrypi 6.12.60-console-v1+ ...

/ # ps aux
PID   USER     COMMAND
    1 root     /bin/sh
    ...
```

âœ… **Success!** You now have:
- âœ“ Your custom kernel (with -console-v1 suffix)
- âœ“ Your custom OS in RAM (initramfs)
- âœ“ Your custom init as PID 1
- âœ“ A completely independent system environment

---

## Phase 7: Access SD Card from Your New OS

Now you have a custom OS running in RAM, but you can still access the physical SD card and files.

### 7.1 View Partitions and Devices

**From your shell (/ #):**
```bash
/ # cat /proc/partitions
/ # ls /dev/mmc*
```

**You'll see:**
```
mmcblk0           (entire SD card)
mmcblk0p1         (FAT boot partition)
mmcblk0p2         (ext4 root of Raspberry Pi OS)
```

---

### 7.2 Enable devtmpfs (if needed)

To get device nodes for all your hardware:
```bash
/ # mount -t devtmpfs devtmpfs /dev
```

This creates dynamic device nodes as the kernel detects hardware.

---

### 7.3 Mount Raspberry Pi OS Root Partition

**What you did:**
```bash
/ # mkdir -p /mnt/pi_root
/ # mount /dev/mmcblk0p2 /mnt/pi_root
/ # ls /mnt/pi_root
```

**You see:**
```
home  etc  usr  boot  var  lib  opt  ...
```

ðŸ‘‰ You're viewing the old Raspberry Pi OS as a DATA DISK from your new OS!

---

### 7.4 Mount Boot Partition (Optional)

```bash
/ # mkdir -p /mnt/boot
/ # mount /dev/mmcblk0p1 /mnt/boot
/ # ls /mnt/boot

bcm2711-rpi-4-b.dtb  cmdline.txt  config.txt  ...
```

You can see and modify Pi OS boot files from your OS.

---

### 7.5 Enter Raspberry Pi OS Using Chroot (Optional)

```bash
/ # chroot /mnt/pi_root /bin/bash
root@raspberrypi:/#
```

You're now in a chroot with:
- Your kernel (still -console-v1)
- Raspberry Pi OS userland on top as a guest system

**Exit:**
```bash
root@raspberrypi:/# exit
/ #
```

Back to your minimal OS.

---

## Conceptual Summary

### Kernel Stage âœ…
Downloaded, configured, compiled, and installed a custom Raspberry Pi kernel with your `-console-v1` suffix.

### Rootfs Stage âœ…
Created a minimal custom OS with:
- BusyBox (300+ Unix tools in one binary)
- Essential directories and device nodes
- Custom `/init` script that runs as PID 1

### Safe Testing âœ…
Used `chroot` to test your rootfs from Raspberry Pi OS WITHOUT touching the actual boot process.

### Initramfs Deployment âœ…
Packaged your rootfs as a compressed archive that:
- Loads into RAM at boot time
- Becomes the root filesystem
- Runs completely independently from the SD card

### Full Independence âœ…
Your Pi now boots with:
1. Your kernel
2. Your OS (in RAM)
3. Full access to the original SD card as just another disk

---

## What Comes Next

From this foundation, you can:

1. **Automate mounting in /init:**
   - Mount /dev, /proc, /sys automatically
   - Mount /dev/mmcblk0p2 for data access
   - No manual commands after boot

2. **Build Console Mode:**
   - Detect game controller input
   - Render graphics to framebuffer
   - Create a proper game launcher/frontend

3. **Optimize for Games:**
   - Add SDL2, libpng, or your rendering library
   - Compile game emulators (MAME, RetroArch, etc.)
   - Create ROM loaders and menu systems

You've established the low-level OS foundation. Now it's time to add the console-specific functionality!

---

## Files Created/Modified
- Kernel: `/boot/firmware/kernel8-console-v1.img`
- Config: `/boot/firmware/config.txt`
- Cmdline: `/boot/firmware/cmdline.txt`
- Initramfs: `/boot/firmware/initramfs-console-v2.cpio.gz`
- Rootfs: `~/os_lab/rootfs/`
- Source: `~/kernel_test/linux/`

## Test Status
âœ… Kernel boots successfully  
âœ… Custom OS boots from initramfs  
âœ… BusyBox shell functional  
âœ… Access to SD card partitions working  
âœ… Chroot environment tested
